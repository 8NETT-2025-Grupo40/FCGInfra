name: Setup EKS Cluster & Add-ons

on:
  workflow_dispatch:
    inputs:
      skip_cluster:
        description: 'Skip cluster creation (cluster already exists)'
        type: boolean
        default: false
      skip_addons:
        description: 'Skip add-ons installation (already installed)'
        type: boolean
        default: false

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: fcg
  AWS_ACCOUNT_ID: 478511033947

jobs:
  setup-cluster:
    name: Create EKS Cluster
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_cluster }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Configura credenciais AWS para permitir que o workflow crie recursos na AWS
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      # eksctl é a ferramenta CLI oficial para criar e gerenciar clusters EKS
      - name: Install eksctl
        run: |
          curl -sLO "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_Linux_amd64.tar.gz"
          tar -xzf eksctl_Linux_amd64.tar.gz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin
          eksctl version
      
      # Cria o cluster EKS usando a configuração em eks/cluster-config.yaml
      # Isso inclui: VPC, node groups, OIDC provider e configurações de rede
      # Tempo estimado: 15-20 minutos
      - name: Create EKS Cluster
        run: |
          eksctl create cluster -f eks/cluster-config.yaml
          echo "Cluster created successfully"
      
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
          kubectl get nodes
  
  setup-namespaces:
    name: Create Namespaces
    runs-on: ubuntu-latest
    needs: [setup-cluster]
    # Executa se o cluster foi criado com sucesso OU se foi pulado (já existe)
    if: ${{ !cancelled() && (needs.setup-cluster.result == 'success' || needs.setup-cluster.result == 'skipped') }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      # Atualiza o kubeconfig local para apontar para o cluster EKS
      # Isso permite usar kubectl para interagir com o cluster
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
      
      # Namespaces são isolamentos lógicos dentro do cluster Kubernetes
      # fcg: namespace principal onde todas as APIs serão deployadas
      # external-secrets: namespace para o operador de sincronização de secrets
      - name: Create Namespaces
        run: |
          kubectl create namespace fcg --dry-run=client -o yaml | kubectl apply -f -
          kubectl create namespace external-secrets --dry-run=client -o yaml | kubectl apply -f -
          echo "Namespaces created"
  
  setup-irsa-alb:
    name: Setup IRSA for AWS Load Balancer Controller
    runs-on: ubuntu-latest
    needs: [setup-namespaces]
    if: ${{ !cancelled() && !inputs.skip_addons }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Install eksctl
        run: |
          curl -sLO "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_Linux_amd64.tar.gz"
          tar -xzf eksctl_Linux_amd64.tar.gz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin
      
      # IAM Policy define as permissões necessárias para o ALB Controller
      # Permite criar/gerenciar Application Load Balancers, Target Groups, etc.
      - name: Create IAM Policy for ALB Controller (if not exists)
        run: |
          # Verifica se a policy já existe para evitar erro de duplicação
          if aws iam get-policy --policy-arn arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:policy/AWSLoadBalancerControllerIAMPolicy 2>/dev/null; then
            echo "Policy already exists"
          else
            echo "Creating IAM policy..."
            aws iam create-policy \
              --policy-name AWSLoadBalancerControllerIAMPolicy \
              --policy-document file://iam/alb-controller-policy.json || true
          fi
      
      # IAM Policy para External Secrets ler secrets do AWS Secrets Manager
      # Permite GetSecretValue e DescribeSecret para secrets específicos
      - name: Create IAM Policy for External Secrets (if not exists)
        run: |
          if aws iam get-policy --policy-arn arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:policy/FCGExternalSecretsPolicy 2>/dev/null; then
            echo "Policy already exists"
          else
            echo "Creating External Secrets IAM policy..."
            aws iam create-policy \
              --policy-name FCGExternalSecretsPolicy \
              --policy-document file://iam/external-secrets-policy.json || true
          fi
      
      # IRSA (IAM Roles for Service Accounts) permite que pods do Kubernetes
      # assumam roles IAM sem precisar de credenciais hardcoded
      # Cria um ServiceAccount no Kubernetes vinculado a uma IAM Role
      - name: Create IRSA for ALB Controller
        run: |
          eksctl create iamserviceaccount \
            --cluster=${{ env.CLUSTER_NAME }} \
            --namespace=kube-system \
            --name=aws-load-balancer-controller \
            --attach-policy-arn=arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:policy/AWSLoadBalancerControllerIAMPolicy \
            --approve \
            --override-existing-serviceaccounts \
            --region=${{ env.AWS_REGION }} || true
          echo "IRSA created for ALB Controller"

  # ============================================
  # CLOUDWATCH APPLICATION SIGNALS IRSA
  # ============================================
  setup-irsa-cloudwatch:
    name: Setup IRSA for CloudWatch Application Signals
    runs-on: ubuntu-latest
    needs: [setup-namespaces]
    if: ${{ !cancelled() && !inputs.skip_addons }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Install eksctl
        run: |
          curl -sLO "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_Linux_amd64.tar.gz"
          tar -xzf eksctl_Linux_amd64.tar.gz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin
      
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
      
      # Namespace para o CloudWatch Agent e ADOT Collector
      - name: Create CloudWatch namespace
        run: |
          kubectl create namespace amazon-cloudwatch --dry-run=client -o yaml | kubectl apply -f -
          echo "Namespace amazon-cloudwatch created"
      
      # IAM Policy para CloudWatch Application Signals
      # Permite enviar logs, traces e métricas para CloudWatch e X-Ray
      - name: Create IAM Policy for CloudWatch Application Signals (if not exists)
        run: |
          if aws iam get-policy --policy-arn arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:policy/CloudWatchApplicationSignalsPolicy 2>/dev/null; then
            echo "Policy already exists"
          else
            echo "Creating CloudWatch Application Signals IAM policy..."
            aws iam create-policy \
              --policy-name CloudWatchApplicationSignalsPolicy \
              --policy-document file://iam/cloudwatch-application-signals-policy.json || true
          fi
      
      # IRSA para CloudWatch Agent - permite enviar telemetria sem credenciais hardcoded
      - name: Create IRSA for CloudWatch Application Signals
        run: |
          eksctl create iamserviceaccount \
            --cluster=${{ env.CLUSTER_NAME }} \
            --namespace=amazon-cloudwatch \
            --name=cloudwatch-agent \
            --attach-policy-arn=arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:policy/CloudWatchApplicationSignalsPolicy \
            --approve \
            --override-existing-serviceaccounts \
            --region=${{ env.AWS_REGION }} || true
          echo "IRSA created for CloudWatch Application Signals"
  
  install-addons:
    name: Install Cluster Add-ons
    runs-on: ubuntu-latest
    needs: [setup-irsa-alb, setup-irsa-cloudwatch]
    if: ${{ !cancelled() && !inputs.skip_addons }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
      
      # Helm é o gerenciador de pacotes do Kubernetes
      # Facilita a instalação e gerenciamento de aplicações complexas
      - name: Install Helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          helm version
      
      # Adiciona repositórios Helm oficiais da AWS e External Secrets
      - name: Add Helm Repositories
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
      
      # AWS Load Balancer Controller observa recursos Ingress no Kubernetes
      # e automaticamente provisiona Application Load Balancers na AWS
      # Isso elimina a necessidade de criar ALBs manualmente
      - name: Install AWS Load Balancer Controller
        run: |
          # Obtém o VPC ID do cluster para configurar o controller
          VPC_ID=$(aws eks describe-cluster --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }} --query 'cluster.resourcesVpcConfig.vpcId' --output text)
          
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            --set clusterName=${{ env.CLUSTER_NAME }} \
            --set serviceAccount.create=false \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set region=${{ env.AWS_REGION }} \
            --set vpcId=$VPC_ID \
            --wait \
            --timeout 5m
          
          echo "AWS Load Balancer Controller installed"
      
      # External Secrets Operator sincroniza secrets do AWS Secrets Manager
      # para Kubernetes Secrets automaticamente
      # Evita armazenar credenciais sensíveis em código ou ConfigMaps
      - name: Install External Secrets Operator
        run: |
          helm upgrade --install external-secrets external-secrets/external-secrets \
            -n external-secrets \
            --set installCRDs=true \
            --wait \
            --timeout 5m
          
          echo "External Secrets Operator installed"
      
      # ============================================
      # CLOUDWATCH APPLICATION SIGNALS
      # ============================================
      # CloudWatch Application Signals fornece observabilidade automática
      # com métricas, traces e logs para aplicações no EKS
      # Usa ADOT (AWS Distro for OpenTelemetry) para coleta de telemetria
      - name: Install CloudWatch Application Signals Add-on
        run: |
          echo "Installing CloudWatch Application Signals add-on..."
          
          # Verifica se o add-on já existe
          if aws eks describe-addon --cluster-name ${{ env.CLUSTER_NAME }} --addon-name amazon-cloudwatch-observability --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "Add-on already exists, updating..."
            aws eks update-addon \
              --cluster-name ${{ env.CLUSTER_NAME }} \
              --addon-name amazon-cloudwatch-observability \
              --region ${{ env.AWS_REGION }} \
              --resolve-conflicts OVERWRITE || true
          else
            echo "Installing add-on..."
            aws eks create-addon \
              --cluster-name ${{ env.CLUSTER_NAME }} \
              --addon-name amazon-cloudwatch-observability \
              --region ${{ env.AWS_REGION }} || true
          fi
          
          echo "CloudWatch Application Signals add-on installed"
      
      # Aguarda os pods do CloudWatch ficarem prontos antes de prosseguir
      - name: Wait for CloudWatch Pods
        run: |
          echo "Waiting for CloudWatch pods to be ready..."
          sleep 30
          
          # Aguarda o DaemonSet estar pronto (pode levar alguns minutos)
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/name=cloudwatch-agent \
            -n amazon-cloudwatch \
            --timeout=300s || true
          
          echo "CloudWatch Application Signals status:"
          kubectl get pods -n amazon-cloudwatch
          kubectl get daemonsets -n amazon-cloudwatch
      
      # Configura retenção de 7 dias para todos os log groups do Application Signals
      # Loop automático busca todos os log groups existentes e aplica a política
      # Isso evita custos com armazenamento indefinido de logs
      - name: Configure Log Retention (7 days)
        run: |
          echo "Configuring log retention for Application Signals log groups..."
          
          # Aplica retenção para log groups do Application Signals
          aws logs describe-log-groups \
            --log-group-name-prefix /aws/application-signals \
            --region ${{ env.AWS_REGION }} \
            --query 'logGroups[].logGroupName' \
            --output text 2>/dev/null | tr '\t' '\n' | while read log_group; do
            if [ ! -z "$log_group" ]; then
              echo "Setting 7-day retention for: $log_group"
              aws logs put-retention-policy \
                --log-group-name "$log_group" \
                --retention-in-days 7 \
                --region ${{ env.AWS_REGION }} || true
            fi
          done
          
          # Aplica retenção para log groups do Container Insights
          aws logs describe-log-groups \
            --log-group-name-prefix /aws/containerinsights/fcg \
            --region ${{ env.AWS_REGION }} \
            --query 'logGroups[].logGroupName' \
            --output text 2>/dev/null | tr '\t' '\n' | while read log_group; do
            if [ ! -z "$log_group" ]; then
              echo "Setting 7-day retention for: $log_group"
              aws logs put-retention-policy \
                --log-group-name "$log_group" \
                --retention-in-days 7 \
                --region ${{ env.AWS_REGION }} || true
            fi
          done
          
          echo "Log retention configured (7 days)"
      
      # Validação robusta: aguarda até que os deployments estejam realmente prontos
      # kubectl wait espera até que a condição 'available' seja verdadeira
      # Isso garante que os pods estão rodando e prontos para receber tráfego
      - name: Verify Installations
        run: |
          echo "Validating deployments are ready..."
          
          # Timeout de 5 minutos para o controller ficar pronto
          echo "Waiting for AWS Load Balancer Controller..."
          kubectl wait --for=condition=available --timeout=300s \
            deployment/aws-load-balancer-controller -n kube-system
          
          echo "Waiting for External Secrets Operator..."
          kubectl wait --for=condition=available --timeout=300s \
            deployment/external-secrets -n external-secrets
          
          echo ""
          echo "Deployment status:"
          kubectl get deployment -n kube-system aws-load-balancer-controller
          kubectl get deployment -n external-secrets external-secrets
          
          echo ""
          echo "CloudWatch Application Signals status:"
          kubectl get pods -n amazon-cloudwatch
          kubectl get daemonsets -n amazon-cloudwatch
          
          echo ""
          echo "Cluster nodes:"
          kubectl get nodes
          
          echo ""
          echo "Node resource usage (monitor memory for t3a.small nodes):"
          kubectl top nodes || echo "Metrics server not available yet"
          
          echo ""
          echo "Cluster setup complete!"
